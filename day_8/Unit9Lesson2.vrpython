{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr_enhanced_robot import *\n\ndrivetrain = Drivetrain()\nmagnet = Electromagnet(\"magnet\", 0)\npen = Pen()\nbrain = Brain()\nleft_bumper = Bumper(\"leftBumper\", 1)\nright_bumper = Bumper(\"rightBumper\", 2)\nfront_eye = EyeSensor(\"fronteye\", 3)\ndown_eye = EyeSensor(\"downeye\", 4)\nright_eye = EyeSensor(\"righteye\", 5)\nleft_eye = EyeSensor(\"lefteye\", 6)\nrear_eye = EyeSensor(\"reareye\", 7)\nfront_distance = Distance(\"frontdistance\", 8)\nrear_distance = Distance(\"reardistance\", 9)\nleft_distance = Distance(\"leftdistance\", 10)\nright_distance = Distance(\"rightdistance\", 11)\nlocation = Location()\npen.set_pen_width(THIN)\ndistance = front_distance\n#endregion VEXcode Generated Robot Configuration\n\n# Drives around, clearing \"Dynamic Castle crasher\" playground\ndef main():\n    # Set speeds to max to save some time in the sim\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n\n    while True:\n        #Does the Distance Sensor detect a castle?\n        if distance.found_object():\n            # Crash castle detected by Distance Sensor\n            drivetrain.drive(FORWARD)\n            \n            # Don't fall off the edge\n            if down_eye.detect(RED):\n                drivetrain.drive_for(REVERSE, 300, MM)\n                drivetrain.turn(RIGHT)\n\n        else: \n            # Turn to find a castle using the Distance Sensor\n            drivetrain.turn(RIGHT)\n\n        wait(5, MSEC)\n\n    stop_project()\n\nvr_thread(main)","textLanguage":"python","rconfig":[],"slot":0,"platform":"PG","sdkVersion":"20220215.18.00.00","appVersion":"2.3.2","fileFormat":"1.0.1","icon":"","targetBrainGen":"First","playground":"DynamicCastleCrasher","robotModel":"vr"}